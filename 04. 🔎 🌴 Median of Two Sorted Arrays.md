# 04. ðŸ”Ž ðŸŒ´ Median of Two Sorted Arrays
https://leetcode.com/problems/median-of-two-sorted-arrays/

Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

## Example 1:
````
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
````
## Example 2:
````
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```` 

## Constraints:

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10^6 <= nums1[i], nums2[i] <= 10^6`

## Solution :

### Approach 1: Using Brute Force

- Crete merge array by merging elements of given two arrays
- sort than in accending order
- find meadian by
- if odd than n/2 element
- if even than (arr[n/2]+arr[n/2-1])/2
  
### Code :

```cpp
// Approach1: Using Brute Force
double Solve(vector<int>& nums1, vector<int>& nums2){
        vector<int>merge;
        int n1=nums1.size();
        int n2=nums2.size();
        for(int i=0;i<n1;i++){
            merge.push_back(nums1[i]);
        }
        for(int i=0;i<n2;i++){
            merge.push_back(nums2[i]);
        }
        sort(merge.begin(),merge.end());
        int m=merge.size();
        double median=0;
        if(m%2==0){
             median=(merge[m/2]+merge[m/2-1])/2.0;
        }else{
              median=merge[m/2];
        }
        return median;
        // TC : O((n1+n2)long(n1+n2))
}
```

### Approach2: Using MinHeap

- Initiate minheap and all two arr element
- Itrate size(minheap)/2+1 times through minheap and maintain prev and cur element
- if size(arr1+arr2) if odd than prev/2 ya curr/2
- if size(arr1+arr2) if odd than (prev+curr)/2
  
### Code :

```cpp
  //Approach2:Using Heap
  double Solve(vector<int>& nums1, vector<int>& nums2){
    int n=nums1.size(),m=nums2.size();
    priority_queue<int,vector<int>,greater<int>>minHeap;
    for(auto it:nums1){
        minHeap.push(it);
    }
    for(auto it:nums2){
        minHeap.push(it);
    }
    int count=minHeap.size()/2+1;
    int m1=-1,m2=-1;
    while(count>0){
        m2=m1;
        m1=minHeap.top();
        minHeap.pop();
        count--;
    }
    if((n+m)%2!=0){
        return m1/1.0;
    }
    return (m1+m2)/2.0;
    // TC O(log(n+m))
    // SC O(n+m)
  }
```

### Approach3: Using Two Pointer

- Itrate size(arr1+arr2)/2 times through num1 and num2 and maintain prev and cur element
- if size(arr1+arr2) if odd than prev/2 ya curr/2
- if size(arr1+arr2) if odd than (prev+curr)/2
  
### Code :

```cpp
  //Approach3:Using Two Pointer
  double Solve(vector<int>& nums1, vector<int>& nums2){
    int n=nums1.size(),m=nums2.size();
    int i=0,j=0;
    int m1=-1,m2=-1;
    for(int count=0;count<=(n+m)/2;count++){
        m2=m1;
        if(i!=n&&j!=m){
            m1=(nums1[i]>nums2[j])?nums2[j++]:nums1[i++];
        }else if(i<n){
            m1=nums1[i++];
        }else if(j<m) m1=nums2[j++];
    }
    if((n+m)%2==0) return (m1+m2)/2.0;
    return m1/1.0;
    // TC O(n+m)
    // SC O(1)
  }
```

### Approach4: Using Binary Search


### Code :

```cpp
  //Approach4 :Using Binary search
  double Solve(vector<int>& nums1, vector<int>& nums2){
    // consider left is smaller that is nums1
    int n=nums1.size(),m=nums2.size();
    // if not smaller than reverse it
    if(n>m) return Solve(nums2,nums1); 

    int s=n+m;
    int left=(s+1)/2;
    int low=0,high=n;

    while(low<=high){
        int mid1=(low+high)/2;
        int mid2=left-mid1;
        int l1=INT_MIN,l2=INT_MIN,r1=INT_MAX,r2=INT_MAX;

        if(mid1<n) r1=nums1[mid1];
        if(mid2<m) r2=nums2[mid2];

        if(mid1-1>=0) l1=nums1[mid1-1];
        if(mid2-1>=0) l2=nums2[mid2-1];

        if(l1<=r2&&l2<=r1){
            if(s%2!=0) return max(l1,l2);
            else return (max(l1,l2)+min(r1,r2))/2.0;
        }else if(l1>r2) high=mid1-1;
        else low=mid1+1;
    }
    return 0;
    // TC O(logn+m)
    // SC O(1)
  }
```