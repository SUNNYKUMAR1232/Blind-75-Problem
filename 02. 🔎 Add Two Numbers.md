# 2. ðŸ”Ž Add Two Numbers
https://leetcode.com/problems/add-two-numbers/

You are given two <b>non-empty</b> linked lists representing two non-negative integers. The digits are stored in <b>reverse order</b>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number `0` itself.

## Example 1:
![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)
````
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
````
## Example 2:
````
Input: l1 = [0], l2 = [0]
Output: [0]
````
## Example 3:
````
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
````

## Constraints:

- The number of nodes in each linked list is in the range `[1, 100]`.
- `0 <= Node.val <= 9`
- It is guaranteed that the list represents a number that does not have leading zeros.
  
<hr>

## Solution
### Approach1: Using Brute Force
#### Intuition: 

>- Step1 :- Form l1 list to n1 number and similar for l2(n2)
>- Step2 :- Sum n1 and n2 
>- Step3 :- Form dummy list by digit by digit traversal in sum

### ***Code:***

#### ***Not Remove Leading zero, so not pass test case***

````cpp
ListNode* Solve(ListNode* l1, ListNode* l2) {
        ListNode* mover1 = l1;
        ListNode* mover2 = l2;
        ListNode* mover = new ListNode(0);
        ListNode* head = mover;
        string s1, s2;
        // sum upto length of l1 and l2
        while (mover1 != NULL || mover2 != NULL) {
            int sum = 0, rem = 0;
            if (mover1)
                s1 += to_string(mover1->val);
            if (mover2)
                s2 += to_string(mover2->val);
            if (mover1)
                mover1 = mover1->next;
            if (mover2)
                mover2 = mover2->next;
        }
        reverse(s1.begin(), s1.end());
        reverse(s2.begin(), s2.end());
        stringstream s3, s4;
        s3 << s1;
        s4 << s2;
        long n1 = 0, n2 = 0;
        s3 >> n1;
        s4 >> n2;
        long sum = n1 + n2;
        while (sum > 0) {
            int rem = sum % 10;
            ListNode* temp = new ListNode(rem);
            mover->next = temp;
            mover = mover->next;
            sum = sum / 10;
        }
        if (l1->val == 0 && l2->val == 0)
            return head;
        ListNode* temp=head;
        head=head->next;
        temp->next=NULL;
        delete temp;
        return head;
        // TC: O(max(l1+l2))
        // SC: O(max(l1+l2))
    }
````
### Approach2: 
#### Intuition: 

- Step1 :- Traversal through l1 or l2 
- Step2 :- Sum val of l1 and l2,carry
- Step3 :- find carry=sum/10 and digit=sum%10
- Step4 :- Create dummy node for add digit 
- Step4 :- Add carry if have in the dummy node

### ***Code:***

````cpp
    ListNode* Solve1(ListNode* l1, ListNode* l2) {
        int sum = 0, carry = 0, rem = 0;
        ListNode* mover1 = l1;
        ListNode* mover2 = l2;
        ListNode* mover = new ListNode(0);
        ListNode* head = mover;
        // sum upto length of l1
        while (mover1 != NULL) {
            if (mover2 != NULL) {
                sum = mover1->val + mover2->val + carry;
                carry = sum / 10;
                rem = sum % 10;
                ListNode* temp = new ListNode(rem);
                mover->next = temp;
                mover2 = mover2->next;

            } else {
                sum = mover1->val + carry;
                carry = sum / 10;
                rem = sum % 10;
                ListNode* temp = new ListNode(rem);
                mover->next = temp;
            }
            mover = mover->next;
            mover1 = mover1->next;
        }
        // sum of remaining l2
        while (mover2 != NULL) {
            sum = mover2->val + carry;
            carry = sum / 10;
            rem = sum % 10;
            ListNode* temp = new ListNode(rem);
            mover->next = temp;
            mover2 = mover2->next;
            mover = mover->next;
        }
        // if carry than add it
        if (carry) {
            ListNode* temp = new ListNode(carry);
            mover->next = temp;
        }
        return head->next;
        // TC: O(max(l1+l2))
        // SC: O(max(l1+l2))
    }
````

````cpp
    ListNode* Solve2(ListNode* l1, ListNode* l2) {
        int carry = 0;
        ListNode* mover1 = l1;
        ListNode* mover2 = l2;
        ListNode* mover = new ListNode(0);
        ListNode* head = mover;
        // sum upto length of l1 and l2
        while (mover1 != NULL || mover2 != NULL) {
            int sum = 0, rem = 0;
            if (mover1)
                sum += mover1->val;
            if (mover2)
                sum += mover2->val;
            sum += carry;
            carry = sum / 10;
            rem = sum % 10;
            ListNode* temp = new ListNode(rem);
            mover->next = temp;
            mover = mover->next;
            if (mover1)
                mover1 = mover1->next;
            if (mover2)
                mover2 = mover2->next;
        }
        // if carry than add it
        if (carry) {
            ListNode* temp = new ListNode(carry);
            mover->next = temp;
        }
        return head->next;
        // TC: O(max(l1+l2))
        // SC: O(max(l1+l2))
    }
````

## Time & Space Complexity
- Time complexity is `O(max(m,n)`. Assume that `m` and `n` represents the length of `l1` and `l2` respectively, the algorithm above iterates at most `max(m, n)` times.
- Space complexity is `O(max(m,n)`. The length of the new list is at most `max(m,n)+1`.